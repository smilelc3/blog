---
title: 2017第八届蓝桥杯决赛题目解析(2)：瓷砖样式
date: 2017-05-29
---

**问题描述：**

> 小明家的一面装饰墙原来是3\*10的小方格。现在手头有一批刚好能盖住2个小方格的长方形瓷砖。
>
> 瓷砖只有两种颜色：黄色和橙色。小明想知道，对于这么简陋的原料，可以贴出多少种不同的花样来。
>
> 小明有个小小的强迫症：忍受不了任何2*2的小格子是同一种颜色。
>
> （瓷砖不能切割，不能重叠，也不能只铺一部分。另外，只考虑图案，请忽略瓷砖的拼接）
>
> 显然，对于2\*3的小格子来说，口算都可以知道：一共10中贴法，如图所示：
>
> 但对于3\*10的格子呢？肯定是个不小的数目，请你利用计算机的威力算出该数字。
>
> 注意：你需要提交的是一个整数，不要填写任何多余的内容（比如：说明性文字）

![](https://raw.githubusercontent.com/smilelc3/blog/main/images/2017第八届蓝桥杯决赛题目解析(2)瓷砖样式/p1-1-1.png)

**问题分析：**

​	题目说的很长，但中心思想一句话就可以概括：用2种 2\*1 瓷砖，覆盖 10\*3 的墙面，保证没有 2\*2 颜色相同，请问有多少种情况？

​	考场上初步想来，直接暴力搜索所有解，最后对所有解进行判定合，足够秒出结果。而且代码简单，不会花费过多时间，为后面大分题准备。

​	现在想来，其实不必对所有解进行判合法，在中途选择瓷砖时，就可以进行判定，这样可以降低时间复杂度。

**问题答案：**

​	**114434**

**代码：**

```c++
#include <iostream>

int a[5][12];   //  -1代表未摆放，1代表黄色，2代表橙色 
int res = 0;

bool judge(int x, int y) {
    if (a[x][y] == a[x - 1][y - 1] && a[x][y] == a[x - 1][y] && a[x][y] == a[x][y - 1])
        return false;
    if (a[x][y] == a[x - 1][y] && a[x][y] == a[x - 1][y + 1] && a[x][y] == a[x][y + 1])
        return false;
    if (a[x][y] == a[x][y - 1] && a[x][y] == a[x + 1][y - 1] && a[x][y] == a[x + 1][y])
        return false;
    return true;

}

void dfs(int x, int y) {
    if (x == 3 && y == 10) {
        res++;
        return;
    }
    if (y > 10) {
        dfs(x + 1, 0);
        return;
    }
    if (a[x][y] == -1) {
        if (a[x][y + 1] == -1)  // 竖着铺 
        {
            a[x][y] = 1;
            a[x][y + 1] = 1;

            if (judge(x, y))    // 边铺边判合法 
                dfs(x, y + 1);
            a[x][y] = -1;
            a[x][y + 1] = -1;

            a[x][y] = 2;
            a[x][y + 1] = 2;
            if (judge(x, y))
                dfs(x, y + 1);
            a[x][y] = -1;
            a[x][y + 1] = -1;
        }
        if (a[x + 1][y] == -1)  // 横着铺 
        {
            a[x][y] = 1;
            a[x + 1][y] = 1;
            if (judge(x, y))
                dfs(x, y + 1);
            a[x][y] = -1;
            a[x + 1][y] = -1;

            a[x][y] = 2;
            a[x + 1][y] = 2;
            if (judge(x, y))
                dfs(x, y + 1);
            a[x][y] = -1;
            a[x + 1][y] = -1;
        }
    } else {
        dfs(x, y + 1);
    }
}


int main() {
    int i, j;
    for (i = 1; i <= 3; i++)
        for (j = 1; j <= 10; j++)
            a[i][j] = -1;
    dfs(1, 1);
    std::cout << res;
    return 0;
}
```

