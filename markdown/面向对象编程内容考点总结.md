---
title: 面向对象编程内容考点总结
date: 2018-1-27
---

![](https://raw.githubusercontent.com/smilelc3/blog/main/images/面向对象编程内容考点总结/u9558912493286204048fm27gp0.jpg)

### 引用调用方式

> 类型名 &引用名 (变量名)
> 或
> 类型名 &引用名 = 变量名

- 引用是别名，建立引用时必须初始化
- 形参是引用，实参是变量

### 内联函数

> inline 类型说明符 被调用函数名(形参表)

1. 必须提前声明和定义
2. 内联函数不交换控制权
3. 不支持递归、循环、switch选择等复杂语句

### 面向对象三大特性

- 继承性
- 封装性
- 多态性

### 类特性

*抽象性 隐藏性 封装性 多态性*

类是对象的抽象， 对象是类的实例

- public 权限开放
- private 仅成员和友元
- protected 成员、友元、派生

| 继承方式  |  public   | protected | private |
| :-------: | :-------: | :-------: | :-----: |
|  public   |  public   | protected | private |
| protected | protected | protected | private |
|  private  |  private  |  private  | private |

### 复制构造函数

> 类名 (const 类名 &对象名)；

const 为保护实参对象可读，可省略
对象名是本类对象的引用，根据需求确定

```c
class A
{
public:
    A(int a);
    A(const A &a);
};
A a(1);
A b(a);     // 方式1
A c = b;    // 方式2
```

### 静态成员(static)

静态数据成员

- 静态数据成员必须初始化，且必须单独初始化
- 定义时候不加 private/public/protected
- 静态数据成员也可以定义为私有的静态数据成员

> 数据类型 类名:: 静态数据成员 = 值；

静态成员函数

- 静态成员函数可以引用静态成员，不能直接引用非静态

> 类名::静态成员函数(参数表)

### 友元

友元函数
可放在类中任意位置，效果相同

> friend 返回类型 函数名(参数表)

友元类

### 派生类构造函数

```
派生类名(派生类构造函数总参数表):<基类构造函数>(<参数表1>),<子对象名>(<参表2>)  
{  
  <派生类中数据成员初始化>
}
```

### 派生类的析构函数

- 先执行派生类的析构函数，再执行基类的析构函数
- 各个基类构造函数的执行顺序取决于定义派生类时所指定的各个基类的顺序，而与派生类构造函数的成员初始化列表中给定的基类顺序无关。

### 动态联编

三条件

1. 虚函数
2. 满足复制兼容规则
3. 成员函数/指针/引用调用虚函数

### 抽象类

- 至少含一个纯虚函数

> virtual <返回值类型> <函数名> (<参数表>)=0;

- 不能建立对象

### 运算符重载

```c
//成员函数
<返回值类型> operator<运算符>(<参数表>)
{
  ……
}
//友元函数
friend <返回值类型> operator<运算符>(<参数表>)
{
  ……
}
```

C

`= [ ] () ->` 这四个运算符只能被重载为类的非静态成员函数

### 赋值兼容规则

- 派生类对象可以赋值给基类对象
- 派生类对象可以初始化基类引用
- 基类对象可以指向派生类对象

### 其他

- *代码复用的三种方式：继承、模板、组合*
- *提取运算符>> ,插入运算符<<*
- *运算符重载要求保持其原来的操作数个数、优先级、结合性和语法结构*
